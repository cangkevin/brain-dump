---
type: fundamentals
tags: SOLID
---

# Interface segregation principle

The interface segregation principle is the fourth letter of the [[solid-principles]].

## Meaning

Robert Martin states this principle as "clients should not be forced to depend upon interfaces that they do not use".

This principle discourages "fat interfaces"; interfaces that are not specific for a single client. Although it is possible for a module to serve many different clients, it's important that those clients are not inadvertently coupled to one another by changes made to the interface that are driven by different client requirements.

## Example

Imagine that we have the following example:

```java
interface FoodOrderService {
  void orderAppetizers(List<FoodItem> appetizers);
  void orderEntrees(List<FoodItem> entrees);
  void orderCombo(int comboMenuItemNumber);
}
```

We have a `FoodOrderService` which represents the range of options of what customers can order at a restaurant.

Imagine now that there is a grand opening promotion for a second, new location and there are items that are only available to that location.

One way to go about it would be just to add it to the existing interface:

```java
interface FoodOrderService {
  void orderAppetizers(List<FoodItem> appetizers);
  void orderEntrees(List<FoodItem> entrees);
  void orderCombo(int comboMenuItemNumber);
  void orderStoreSpecificItem(int storeSpecificItemNumber);
}
```

At first glance, this seems like a reasonable solution but the issue lies in that all implementing classes (the restaurants) of this interface now has to implement something for  `orderStoreSpecificItem`, even if they are not offering items specific to their store only.

Hence, a client was impacted by a change made by another client that had different requirements, which goes against the ISP.

A different way of going about it that conforms to the ISP is to treat these as two separate interfaces.

```java
interface FoodOrderService {
  void orderAppetizers(List<FoodItem> appetizers);
  void orderEntrees(List<FoodItem> entrees);
  void orderCombo(int comboMenuItemNumber);
}

interface StorePromotionalOrderService {
  void orderStoreSpecificItem(int storeSpecificItemNumber);
}
```

This approach now allow clients of `FoodOrderService` to be agnostic of anything that goes on with store-specific items. Classes that implement the interface can selectively opt-in implementing `StorePromotionalOrderService` whenever they want without worrying about impacting any existing `FoodOrderService` clients.

This allows clients of both `FoodOrderService` and `StorePromotionalOrderService` to be de-coupled from each other.

[//begin]: # "Autogenerated link references for markdown compatibility"
[solid-principles]: solid-principles.md "SOLID principles"
[//end]: # "Autogenerated link references"
